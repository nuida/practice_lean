# Leanによる定理証明の勉強メモ

## 注意書き
（2023年9月12日作成、2023年9月14日最終更新）

- この文書は、プログラミングを少しだけできる（謙遜とかネットミームの「チョットデキル」ではなく、文字通りに）筆者が、Leanによる定理証明に興味を持って独学を始めたものの、日本語で説明が書かれたウェブページが（皆無ではないものの）ほとんど見つからず（2023年9月現在）難儀しているので、同様の状況に陥っているかもしれない方のことを考えるととにかく（質には目をつぶって）「日本語でLeanのことが書かれたページ」を増やした方がよさそうだなぁと思ったので（あと、自分用の備忘録も兼ねて）作成・公開しているものです。
つまり、書かれた内容が確実に正しいことを筆者は保証しませんし、文書に含まれるコードの具体例はそれが「良い」コードであることを含意しません。
- なお、（筆者が知っている、数少ない）日本語のまとまった参考文献として以下を挙げておきます。
本文書はあまり系統的な記述にはならないと思いますので、系統的な説明を欲している方はそちらを参照してください。
  - [Theorem Proving in Lean 4の日本語訳](https://aconite-ac.github.io/theorem_proving_in_lean4_ja/title_page.html)
  - [「数学系のためのLean勉強会」の記録（教材付き）](https://haruhisa-enomoto.github.io/lean-math-workshop/)
- [ライブラリMathlib4のドキュメントのページ](https://leanprover-community.github.io/mathlib4_docs/)には、Mathlib4だけでなく標準の（つまり、何もimportしなくてもそのまま使える）機能についての説明も書かれています（ただしすべて英語ですが…）。
同ページからは対応するソースコードも参照できます。
ある機能の仕様がどうしてもわからないという場合は、上記ページから辿れるソースコードを頑張って解読する羽目になります。
- この文書の内容はLean 4、より詳しくはバージョン 4.0.0-nightly-2023-07-20 に基づいています。
また、筆者の環境ではWindows上でVisual Studio Codeの拡張機能を用いてLeanのコードを書いています。
なお、Lean自体のインストールの方法などは（筆者自身もよくわからないまま、色々と検索しつつ試していたら何とかできたというありさまなので）筆者は説明できません。

## 全体的な雑感
（2023年9月12日作成）

- Leanは各オブジェクトに型がしっかりと定められている類（←正式な名称がわかりません）の言語です。
そして、Leanではこの型を検査する機能を活用して定理の証明の検証が行えます…ということらしいです。
現時点での私の理解では、
  - 型の種類の中に「命題の型」と、命題Pの各々について「Pの正しい証明の型」が存在します。
  - 「命題Pの正しい証明」の候補である何らかの証明を与えたとき、その証明が「『命題Pの正しい証明』型のオブジェクト」であることが（Leanの型推論の機能により）確認できれば、そのことが「命題Pが正しく証明できた」ことを意味します。
  - Leanでは「型Tのオブジェクトを型T'のオブジェクトに写す写像（関数）」の型を `T → T'` で表し、また命題の含意（「ならば」）も（二重矢印「`⇒`」ではなく）記号 `→` で表されます。
  この記号が重複しているのは偶然ではなく、Leanの論理体系における命題の含意とは「前件（「ならば」の前の部分）の正しい証明」（より正確には「『前件の正しい証明』型のオブジェクト）から「後件（「ならば」の後の部分）の正しい証明」を得る具体的な手順が存在すること、すなわち「前件の正しい証明」を「後件の正しい証明」に写す写像が存在することを（恐らく）意味するからです。
- 上で述べたような「命題Pの正しい証明から命題Qの正しい証明を得る具体的な操作が与えられたときにのみ、『PならばQ』が真であると結論付ける」という特徴は直観主義論理を想起させます。
実際、（どこに書いてあったのか失念しましたが、）Leanの論理構造はいわゆる古典論理ではなく直観主義論理に基づいているとのことです。

## 証明の簡単な例
（2023年9月15日作成）

Leanによる定理証明の簡単な例として、自然数 $a$ と $b$（注：Leanでは「自然数」とは非負整数のことです）が $a \leq b$ を満たせば $a + 1 \leq b + 2$ を満たす、という定理とその証明のコードを示します。
ここでは「定理」という語には「価値の高い結果」といったニュアンスはなく、単に「証明された命題」という意味です。

```
-- 名前のない定理とその証明の例  -- 1行目
example : ∀ a b : Nat, a ≤ b → a + 1 ≤ b + 2 := by  -- 2行目
  intro a b  -- 3行目
  intro h_ab  -- 4行目
  have h_12 : 1 ≤ 2 := by trivial  -- 5行目
  apply Nat.add_le_add h_ab h_12  -- 6行目
```

<details><summary>各行の説明はこちら</summary>

- 1行目：単なるコメントです。このようにマイナス記号二つ `--` を続けて書くと、その行のそれ以降の箇所はコメント扱いになります。
（上のコードでは他の行も含めて右端に行番号を付けていますが、付けなくても動作に影響はありません。）
- 2行目：定理のステートメントです。
  - 「定理」なのに `example` と書いてありますが、これはLeanでは「名前の付かない定理」を表します。
  - 最初のコロン `:` から `by` の前にある `:=` までが定理のステートメント本体です。
  数学の論理記号に慣れていれば意味は推測しやすいと思いますが、詳しい説明は以下の通りです。
    - `∀ a b : Nat,` の部分は（ほぼ見たまんま）「任意の自然数aとbに対して、」の意味です。
      - `Nat` は自然数の型を表します。
      つまり上の部分をもう少し直訳すると「自然数の型をもつ任意の対象 $a$ と $b$ に対して」といった具合になります。
      - なお、 `a` と `b` の間にはカンマは不要です（むしろカンマを入れるとエラーになります）が、上記部分の最後にはカンマが必要です。
    - 残りの部分はもっと見たまんま、「$a \leq b$ ならば $a + 1 \leq b + 2$ である」の意味です。
      - 注意点としては、[「全体的な雑感」の節](#全体的な雑感)にも書いたように、命題の含意（「ならば」）の記号は `⇒` ではなく `→` であるということです。
      - なお、ステートメントが長い場合などには2行以上にわたって書くことも可能です。
  - `:=` の後ろの部分（以降の行も含めて）が証明の中身を表します。
    - この記号 `:=` は「左辺の値を右辺で定義する」という（数学でもしばしば使われる）記号と同じものですが、これも偶然ではなく、上の構文は「 `∀ a b : Nat, a ≤ b → a + 1 ≤ b + 2` という命題の正しい証明」の型をもつ対象（ここでは名前が付いていない）を `:=` 以降の内容で定義する、という意味と理解できます。
    （Leanでは例えば「自然数の型をもつ対象 x の値を 2 と定義する」を `def x : Nat := 2` と書いたりしますが、これと上記の構文の類似性が感じられると思います。
  - `:=` の直後の `by` は（筆者は詳しい仕組みをわかっていませんが）「手続き的なスタイルで証明を書きます」という宣言のようなものです。
- 3行目：証明を記述する手続きを開始した時点で、証明の目標となる命題（「ゴール」）は `∀ a b : Nat, a ≤ b → a + 1 ≤ b + 2` に設定されます。  
3行目の冒頭の `intro` というコマンド（Leanでは「タクティク」 "tactic" と呼ばれます）により、ゴールの命題の冒頭の `∀ a b : Nat` に対応する命題として「 $a$ の型は Nat である」「 $b$ の型は Nat である」という二つの「仮定」が導入されます。  
そして、ゴールの命題は上記部分を除いた命題 `a ≤ b → a + 1 ≤ b + 2` へと置き換えられます。
  - なお、`intro` の後の `a b` は、上記のような `Nat` 型の対象二つを `a` および `b` と名付けるといった意味ですが、これらの記号は（既存の記号と重複していなければ）ステートメントで用いられた記号と同じである必要はありません。
  例えばここを `intro c d` と書き変えても（以降を必要に応じて適切に書き換えれば）構いません。
- 4行目：この時点での仮定は `a : Nat` と `b : Nat` の二つ（それぞれ、`a` や `b` が `Nat` 型であることを表します）、またゴールは `a ≤ b → a + 1 ≤ b + 2` となっています。  
4行目の `intro` は、このゴールの前件である命題 `a ≤ b` を（ `h_ab` という名前を付けて）仮定のリストへ移し、ゴールの命題を `a + 1 ≤ b + 2` へと書き換えます。
  - なお、前述のことと同様に、 `h_ab` はより正確には「命題 `a ≤ b` の証明、という型をもつ対象」を意味しています。
- 5行目：この時点での仮定は `a : Nat` と `b : Nat` と `a ≤ b` の三つ、ゴールは `a + 1 ≤ b + 2` です。  
5行目の `have` コマンドは、証明の途中経過として命題（「補題」と呼んだ方がしっくりくるかもしれません）`1 ≤ 2` を証明し、その命題を仮定のリストへ追加します。
  - 2行目と同様に、 `:= by` 以降はこの命題の（手続き的なスタイルでの）証明を表します。ただし今回の命題は「自明な」命題であるため、単に `trivial` と書くだけで証明が済んでしまいます。
    - 筆者は命題がいつ「自明」なのかの基準を把握していませんが、試しに `trivial` と書いてみて、Leanに叱られたら真面目に証明を書く、という（人間相手のセミナーなどでは怒られそうな）やり方が可能です。
- 6行目：ここが一番複雑な箇所です。
  - `Nat.add_le_add` は、Leanに標準で用意されている定理で、意味合いとしては「自然数 $x, y, z, w$ について、$x \leq y$ かつ $z \leq w$ であれば $x + z \leq y + w$ である」というものです。
    - 定理の名称が `Nat.` で始まっているのは、名前空間という概念を知っていると理解しやすいですが、「自然数（ Nat 型）に関連する定理だから」ぐらいの理解でもひとまず困らないと思います。
    - なお、Visual Studio Codeの拡張機能を使っている場合には、とりあえず `Nat.` と打ち込むと自然数に関連する既存の定理名をサジェストしてくれるので、欲しい定理が用意されているかどうか探すのに便利です。  
    また、例えば不等式に関する定理を探す場合には、 `Nat.` の後にさらに `le` （ "less than or equal to"を略したキーワード、だと思います）と打ち込むことで、名称に"le"が含まれる、つまり不等式に関連する可能性が高い定理の候補に絞ったサジェストをしてもらえるようになります。
  - `Nat.add_le_add h_ab h_12` と書くことで、この定理を、既に仮定のリストに入っている命題 `h_ab` 「 $a \leq b$ 」および `h_12` 「 $1 \leq 2$ 」に適用して、定理から導かれる結論として命題「 $a + 1 \leq b + 2$ 」を得ることができます。
    - なお、一般に命題 $P, Q, R$ に対して $(P \land Q) \to R$ と $P \to Q \to R$ （括弧を補って書くと、 $P \to (Q \to R)$ ）は同値ですが、上記の定理 `Nat.add_le_add` も実際には（ $(x \leq y \land z \leq w) \to x + z \leq y + w$ 、ではなく） $x \leq y \to z \leq w \to x + z \leq y + w$ という流儀で実装されています。  
    後者のように実装することで、上記のようにこの定理を `h_ab` と `h_12` に逐次的に適用する書き方ができています。
    これをもし前者のような（前件の部分に「かつ」 $\land$ が現れる）流儀で実装したとすると、この定理は仮定「 `h_ab ∧ h_12` 」に適用する必要があり、この仮定を用意するために「命題と命題を $\land$ で結ぶ」という別の操作を要します。
    この面倒を回避するために前者の流儀での実装が採用されているのだろうと推測します。
  - そして、行頭の `apply` コマンドにより、上記の命題を現在のゴールの命題に適用することができます。 `apply` コマンドは本来は「ある命題を用いて、ゴールの命題を変形する」機能があるのですが、今回は `apply` コマンドで用いる命題とゴールの命題が一致しているため、このコマンドで証明が完了してくれています。

</details>

もちろん、通常の数学と同様に、同じ定理であっても正しい証明はいくつも存在します。
上の例と同じ定理を別の方針で証明するコードの例を示します。

```
/- 先程と同じ定理を別の方針で証明する
   （今度は定理に名前を付けている） -/
theorem toy_example  -- ステートメント中での改行の例
: ∀ a b : Nat, a ≤ b → a + 1 ≤ b + 2 := by  
  intro a b h_ab
  have : a ≤ b + 1 := Nat.le_succ_of_le h_ab
  have : a + 1 ≤ b + 2 := Nat.succ_le_succ this
  exact this  -- Q.E.D.
```

<details><summary>前の例との主な相違点はこちら</summary>

- `/-` と `-/` で挟んだ箇所もコメントとして扱われます。
 `--` の場合とは異なり、こちらは複数行にまたがるコメントも書けます。
- 今回は定理に名前 `toy_example` を付けています。
そのため、冒頭のキーワードも `example` から `theorem` に変わっています。
- 前の例では説明の都合で `intro` を2回（3行目と4行目）に分けて使いましたが、今回の例のように、（仮定に追加するのが「任意の対象」であるか命題であるかにかかわらず） `intro` を一つにまとめて書くことができます。
- 6行目の `Nat.le_succ_of_le` と7行目の `Nat.succ_le_succ` は、それぞれ（自然数について）「 $a \leq b$ ならば $a \leq b + 1$ 」、「 $a \leq b$ ならば $a + 1 \leq b + 1$ 」という定理です。
- 6行目の証明の部分には `by` が付いていませんが、これは証明を手続き的に構成するまでもなく、単に定理の適用一発で必要な証明が構成できるからです。
7行目も同様です。
- 6行目の `have` コマンドで示した命題には名前が付いていません。
このように、示した命題を直後のコマンドでのみ用いる場合には、命題の名称を省略した上で `this` というキーワードでその（直前に示した）命題を参照できます。
7行目も同様です。
- 最後、8行目の `exact` コマンドは、（筆者の理解では）既に正しいことがわかっている（それまでに仮定のリストに追加したり、別の定理を適用するなどで得られた）命題を提示して「これが示すべきことであった」と証明を完了するコマンドだと思います。

</details>

なお、上記のように定理に名前を付けておくと、Leanの側で用意してある定理と同様に、自分で証明した定理も別の場面で利用できるようになります。
以下の例の4行目を参照してください。

```
example : ∀ a b : Nat, a ≤ b → a + 2 ≤ b + 3 := by
  intro a b h_ab
  have : a + 1 ≤ b + 1 := Nat.succ_le_succ h_ab
  apply toy_example (a + 1) (b + 1)
  exact this
--  trivial
--  assumption
```

<details><summary>この例の説明はこちら</summary>

- 4行目の `apply` について、この時点でのゴールは `a + 2 ≤ b + 3` です。
一方、定理 `toy_example` を値 `a + 1` と `b + 1` に適用して得られる命題は `a + 1 ≤ b + 1 → a + 2 ≤ b + 3` です。この命題を適用することで、ゴールを `a + 2 ≤ b + 3` から `a + 1 ≤ b + 1` へと変換しています。
（通常の数学の証明で「主張を示すには〇〇であることを示せばよい。」のように書いたりしますが、これと対応していると思います。）
- `intro` の最後で仮定 `a ≤ b` を得ているので、直ちに「定理 `toy_example` を `a + 1` と `b + 1` に適用して `a + 2 ≤ b + 3` を得る」とやりたくなります。しかし、関係 `a + 1 ≤ b + 1` は（Leanの基準では） `a ≤ b` から「自明に」得られるものではないため、一旦 `a + 1 ≤ b + 1` を証明しておくというステップが必要になります。
- 5行目の時点でのゴールは、3行目（直前の `have` ）で示した命題 `a + 1 ≤ b + 1` と同じものになっています。そのため `exact this` で証明を完了できていますが、それ以外にも `trivial`  というコマンドも適用できます。さらに、既に仮定のリストに追加された命題のうち適切なものを適用する、というコマンド `assumption` を用いても証明が完了します。

</details>

## 集合に関する簡単な例の話（作成中）


